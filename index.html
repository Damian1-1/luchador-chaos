<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<title>Turowa gra wrestlingowa z drag&drop i atakiem</title>
<style>
  #board {
    display: grid;
    grid-template-columns: repeat(6, 60px);
    grid-template-rows: repeat(6, 60px);
    gap: 3px;
    margin-bottom: 15px;
    user-select: none;
  }
  .cell {
    width: 60px;
    height: 60px;
    background-color: #eee;
    border: 1px solid #ccc;
    position: relative;
  }
  .cell.highlight-move {
    background-color: #bdf !important;
  }
  .cell.highlight-attack {
    background-color: #fbb !important;
  }
  .cell .wrestler {
    width: 56px;
    height: 56px;
    background-color: #2277cc;
    border-radius: 8px;
    margin: 2px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    font-weight: bold;
    user-select: none;
    cursor: grab;
  }
  .cell .wrestler.selected {
    outline: 3px solid #ff0;
  }
  .cell .wrestler.enemy {
    background-color: #a22;
    cursor: pointer;
  }
  .cell .wrestler.attack {
    animation: attackAnim 0.8s;
  }
  @keyframes attackAnim {
    0%, 100% { transform: translateX(0); }
    50% { transform: translateX(10px); }
  }
  #info-panel {
    border: 1px solid #ccc;
    padding: 10px;
    max-width: 400px;
    background: #f9f9f9;
  }
  .cards-container {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin: 10px 0;
  }
  .card {
    background: #def;
    border: 1px solid #aac;
    border-radius: 5px;
    padding: 4px 6px;
    width: 110px;
    cursor: pointer;
    user-select: none;
  }
  .card.selected {
    background-color: #48a !important;
    color: white;
  }
  button {
    margin: 5px 4px 5px 0;
    padding: 6px 12px;
  }
</style>
</head>
<body>
<h2>Turowa gra wrestlingowa z drag&drop i atakiem</h2>
<div id="board"></div>
<div id="info-panel"></div>

<script>
  const BOARD_SIZE = 6;
  let gameState = {
    board: [],
    wrestlers: [],
    currentPlayerIndex: 0,
    turn: 1,
    selectedCardIndex: null,
    selectedTarget: null, // cel ataku
    dragSource: null,
    animationLock: false,
  };

  const ACTION_CARDS = [
    {
      id: 1,
      name: 'Ruch',
      type: 'move',
      description: 'Przesuń zawodnika o 2 pola w dowolnym kierunku (drag&drop).',
    },
    {
      id: 2,
      name: 'Atak',
      type: 'attack',
      description: 'Kliknij przeciwnika w zasięgu 1 pola, potem użyj karty, by zaatakować.',
    },
    {
      id: 3,
      name: 'Obrona',
      type: 'defend',
      description: 'Zwiększ obronę o 2 na tę turę (działa od razu po użyciu).',
    },
    {
      id: 4,
      name: 'Specjalny cios',
      type: 'special',
      description: 'Zadaj 4 obrażenia przeciwnikowi w zasięgu 1 pola.',
    }
  ];

  function initBoard() {
    gameState.board = [];
    for(let y=0; y<BOARD_SIZE; y++) {
      let row = [];
      for(let x=0; x<BOARD_SIZE; x++) {
        row.push(null);
      }
      gameState.board.push(row);
    }
  }

  function initWrestlers() {
    gameState.wrestlers = [
      { id: 1, name: 'Gracz1', hp: 10, defense: 0, isAlive: true, position: {x: 0, y: 0}, hand: [], equipment: [] },
      { id: 2, name: 'AI', hp: 10, defense: 0, isAlive: true, position: {x: BOARD_SIZE-1, y: BOARD_SIZE-1}, hand: [], equipment: [] },
    ];
  }

  function renderBoard() {
    const boardEl = document.getElementById('board');
    boardEl.innerHTML = '';
    for(let y=0; y<BOARD_SIZE; y++) {
      for(let x=0; x<BOARD_SIZE; x++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.x = x;
        cell.dataset.y = y;

        const wrestlerHere = gameState.wrestlers.find(w => w.isAlive && w.position.x === x && w.position.y === y);
        if(wrestlerHere) {
          const wEl = document.createElement('div');
          wEl.className = 'wrestler';
          wEl.textContent = wrestlerHere.name[0];

          // Kolor w zależności od gracza
          if(gameState.currentPlayerIndex === gameState.wrestlers.indexOf(wrestlerHere)) {
            wEl.style.backgroundColor = '#2a7';
            wEl.setAttribute('draggable', 'true');
          } else {
            wEl.style.backgroundColor = '#a22';
            wEl.classList.add('enemy');
          }

          // Zaznaczony atakujący zawodnik
          if(gameState.dragSource === wrestlerHere) {
            wEl.classList.add('selected');
          }

          // Klikalność przeciwnika jeśli karta ataku wybrana i w zasięgu
          if(gameState.selectedCardIndex !== null) {
            const card = gameState.wrestlers[gameState.currentPlayerIndex].hand[gameState.selectedCardIndex];
            if(card.type === 'attack' || card.type === 'special') {
              const attacker = gameState.wrestlers[gameState.currentPlayerIndex];
              if(wrestlerHere !== attacker && distance(attacker.position, wrestlerHere.position) <= 1) {
                wEl.style.cursor = 'pointer';
                wEl.onclick = () => {
                  if(gameState.animationLock) return;
                  gameState.selectedTarget = wrestlerHere;
                  renderInfoPanel();
                };
                if(gameState.selectedTarget === wrestlerHere) {
                  wEl.style.outline = '3px solid yellow';
                } else {
                  wEl.style.outline = '';
                }
              }
            }
          }

          // Obsługa drag & drop
          if(gameState.currentPlayerIndex === gameState.wrestlers.indexOf(wrestlerHere)) {
            wEl.addEventListener('dragstart', onDragStart);
          }

          cell.appendChild(wEl);
        }

        // Highlighty do ruchu
        if(gameState.selectedCardIndex !== null) {
          const card = gameState.wrestlers[gameState.currentPlayerIndex].hand[gameState.selectedCardIndex];
          const currentWrestler = gameState.wrestlers[gameState.currentPlayerIndex];
          if(card.type === 'move') {
            if(distance({x, y}, currentWrestler.position) <= 2 && !cellHasWrestler(x,y)) {
              cell.classList.add('highlight-move');
              cell.addEventListener('dragover', onDragOver);
              cell.addEventListener('drop', onDrop);
            }
          }
        }

        boardEl.appendChild(cell);
      }
    }
  }

  function cellHasWrestler(x, y) {
    return gameState.wrestlers.some(w => w.isAlive && w.position.x === x && w.position.y === y);
  }

  function onDragStart(ev) {
    if(gameState.animationLock) {
      ev.preventDefault();
      return;
    }
    const x = +ev.target.parentElement.dataset.x;
    const y = +ev.target.parentElement.dataset.y;
    const wrestler = gameState.wrestlers.find(w => w.position.x === x && w.position.y === y);
    if(!wrestler || gameState.wrestlers[gameState.currentPlayerIndex] !== wrestler) {
      ev.preventDefault();
      return;
    }
    const card = gameState.wrestlers[gameState.currentPlayerIndex].hand[gameState.selectedCardIndex];
    if(!card || card.type !== 'move') {
      ev.preventDefault();
      alert('Wybierz kartę ruchu, żeby przeciągać zawodnika.');
      return;
    }
    gameState.dragSource = wrestler;
    ev.dataTransfer.setData('text/plain', JSON.stringify({x, y}));
  }

  function onDragOver(ev) {
    ev.preventDefault();
  }

  function onDrop(ev) {
    ev.preventDefault();
    if(gameState.animationLock) return;
    const targetX = +ev.target.dataset.x;
    const targetY = +ev.target.dataset.y;
    const sourcePos = gameState.dragSource.position;
    if(distance(sourcePos, {x: targetX, y: targetY}) > 2) {
      alert('Możesz się przesunąć max o 2 pola.');
      return;
    }
    if(cellHasWrestler(targetX, targetY)) {
      alert('To pole jest zajęte.');
      return;
    }
    // Przesuń zawodnika
    gameState.dragSource.position = {x: targetX, y: targetY};
    gameState.selectedCardIndex = null; // karta zużyta
    gameState.dragSource = null;
    gameState.selectedTarget = null;
    renderAll();
  }

  function distance(p1, p2) {
    return Math.max(Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y));
  }

  function renderCards() {
    const panel = document.getElementById('info-panel');
    const player = gameState.wrestlers[gameState.currentPlayerIndex];
    let html = `<b>Tura: ${gameState.turn} | Gracz: ${player.name}</b><br>HP: ${player.hp} | Obrona: ${player.defense}<br><br>`;
    html += 'Karty (kliknij, by wybrać):<br><div class="cards-container">';
    player.hand.forEach((card, i) => {
      html += `<div class="card${gameState.selectedCardIndex === i ? ' selected' : ''}" data-index="${i}">${card.name}<br><small>${card.description}</small></div>`;
    });
    html += '</div>';
    html += `<button id="use-card" disabled>Użyj karty</button> `;
    html += `<button id="end-turn">Zakończ turę</button>`;

    panel.innerHTML = html;

    // Karty - klik
    const cardsEls = panel.querySelectorAll('.card');
    cardsEls.forEach(el => {
      el.onclick = () => {
        if(gameState.animationLock) return;
        const idx = +el.dataset.index;
        if(gameState.selectedCardIndex === idx) {
          gameState.selectedCardIndex = null;
          gameState.selectedTarget = null;
        } else {
          gameState.selectedCardIndex = idx;
          gameState.selectedTarget = null;
          gameState.dragSource = null;
        }
        renderAll();
      };
    });

    // Przycisk użycia karty
    const useBtn = document.getElementById('use-card');
    useBtn.disabled = (gameState.selectedCardIndex === null);

    // Aktywacja przycisku tylko gdy jest cel jeśli trzeba
    if(gameState.selectedCardIndex !== null) {
      const card = player.hand[gameState.selectedCardIndex];
      if((card.type === 'attack' || card.type === 'special') && !gameState.selectedTarget) {
        useBtn.disabled = true;
      }
    }

    useBtn.onclick = () => {
      if(gameState.animationLock) return;
      playCard();
    };

    // Koniec tury
    document.getElementById('end-turn').onclick = () => {
      if(gameState.animationLock) return;
      nextTurn();
    };
  }

  function playCard() {
    const player = gameState.wrestlers[gameState.currentPlayerIndex];
    const card = player.hand[gameState.selectedCardIndex];
    if(!card) return;

    switch(card.type) {
      case 'move':
        alert('Ruch wykonany przeciągnięciem. Wybierz inną kartę lub zakończ turę.');
        break;

      case 'attack':
        if(!gameState.selectedTarget) {
          alert('Wybierz przeciwnika do ataku.');
          return;
        }
        attack(player, gameState.selectedTarget, 2);
        break;

      case 'defend':
        player.defense += 2;
        alert(`${player.name} podnosi obronę o 2!`);
        break;

      case 'special':
        if(!gameState.selectedTarget) {
          alert('Wybierz przeciwnika do specjalnego ataku.');
          return;
        }
        attack(player, gameState.selectedTarget, 4);
        break;
    }
    // Usuwamy kartę z ręki po użyciu
    player.hand.splice(gameState.selectedCardIndex, 1);
    gameState.selectedCardIndex = null;
    gameState.selectedTarget = null;
    renderAll();
  }

  function attack(attacker, defender, damage) {
    gameState.animationLock = true;
    const defenderEl = [...document.querySelectorAll('.wrestler.enemy')]
      .find(el => {
        const x = +el.parentElement.dataset.x;
        const y = +el.parentElement.dataset.y;
        return defender.position.x === x && defender.position.y === y;
      });

    if(defenderEl) {
      defenderEl.classList.add('attack');
      setTimeout(() => {
        defenderEl.classList.remove('attack');
        let actualDamage = Math.max(0, damage - defender.defense);
        defender.hp -= actualDamage;
        if(defender.hp <= 0) {
          defender.isAlive = false;
          alert(`${defender.name} został pokonany!`);
        } else {
          alert(`${attacker.name} zadał ${actualDamage} obrażeń ${defender.name}.`);
        }
        gameState.animationLock = false;
        renderAll();
      }, 800);
    } else {
      // Nie znaleziono elementu, wykonujemy od razu
      let actualDamage = Math.max(0, damage - defender.defense);
      defender.hp -= actualDamage;
      if(defender.hp <= 0) {
        defender.isAlive = false;
        alert(`${defender.name} został pokonany!`);
      } else {
        alert(`${attacker.name} zadał ${actualDamage} obrażeń ${defender.name}.`);
      }
      gameState.animationLock = false;
      renderAll();
    }
  }

  function nextTurn() {
    // Reset obrony na koniec tury
    gameState.wrestlers.forEach(w => {
      w.defense = 0;
    });

    // Przełącz gracza
    gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.wrestlers.length;

    // Nowa tura?
    if(gameState.currentPlayerIndex === 0) {
      gameState.turn++;
    }

    // Dodaj nowe karty do ręki (losowo)
    const player = gameState.wrestlers[gameState.currentPlayerIndex];
    if(player.isAlive) {
      while(player.hand.length < 3) {
        const newCard = ACTION_CARDS[Math.floor(Math.random()*ACTION_CARDS.length)];
        player.hand.push({...newCard});
      }
    }

    gameState.selectedCardIndex = null;
    gameState.selectedTarget = null;
    gameState.dragSource = null;
    renderAll();
  }

  function renderInfoPanel() {
    renderCards();
  }

  function renderAll() {
    renderBoard();
    renderInfoPanel();
  }

  function startGame() {
    initBoard();
    initWrestlers();
    // Na start 3 karty dla każdego
    gameState.wrestlers.forEach(w => {
      w.hand = [];
      while(w.hand.length < 3) {
        const newCard = ACTION_CARDS[Math.floor(Math.random()*ACTION_CARDS.length)];
        w.hand.push({...newCard});
      }
    });
    gameState.currentPlayerIndex = 0;
    gameState.turn = 1;
    gameState.selectedCardIndex = null;
    gameState.selectedTarget = null;
    gameState.dragSource = null;
    renderAll();
  }

  startGame();

</script>
</body>
</html>
